
// $Id$

/** \file compile.h
  
    Functions for use by "compiler" (i.e., parser) are here.
*/

#ifndef COMPILE_H
#define COMPILE_H

#include <stdlib.h>

class expr;
class parser_list;
class option;

/// The actual tokenizer; generated by flex.
int yylex();

// Redirect error messages
void yyerror(const char *msg);


/** For debugging the parser itself.
    Under normal operation, thus function does nothing.
    When debugging, the info string is displayed.
      @param  info  Reduction rule information.
*/
void Reducing(const char* info);


// ******************************************************************
// *                                                                *
// *                                                                *
// *                     List-related functions                     *
// *                                                                *
// *                                                                *
// ******************************************************************


/** Adds a statement to our internal list (which may be null).
      @param s  statement to add (ignored if NULL)
*/
void AppendStatement(expr* s);

/** Builds a single statement from a list of statements.
*/
expr* MakeStatementBlock(parser_list* stmts);

/** Add expression to a list.
    If the list is "collapsable", then if the list contains a single null 
    or error expression, then we collapse the list into a single node
    containing a null or error expression.
      @param  behv  How to deal with null or error expressions?
                      0: add them to the list anyway.
                      1: don't add them to the list.
                      2: if we see one, collapse the entire list.
      @param  list  List of expressions.
      @param  item  Item to add to the list.
      @return The new list.
*/
parser_list* AppendExpression(int behv, parser_list* list, expr* item);

/** Add a term to a list of sums or products.
      @param  list  List of objects (0 for empty).
      @param  op    Operator.
      @param  term  The term of the expression.
      @return An updated list.
*/
parser_list* AppendTerm(parser_list* list, int op, expr* term);

/** Add a name to our list of names.
      @param  list  List of names (or 0 for empty).
      @param  ident New name to add.  Will eventually be free()d.
      @return A new list.
*/
parser_list* AppendName(parser_list* list, char* ident);


// ******************************************************************
// *                                                                *
// *                                                                *
// *                  Statement-related  functions                  *
// *                                                                *
// *                                                                *
// ******************************************************************

/** Make a constraint statement.
      @param  x  The constraint expression.
*/
expr* MakeConstraint(expr *x);

/** Build an option statement.
      @param  o  Option to set.
      @param  v  Value to assign to the option.
      @return A new statement, as appropriate.
*/
expr* BuildOptionStatement(option* o, expr* v);

/** Build an (enumerated) option statement.
      @param  o   Option to set.
      @param  n   Name of radio button to assign to the option.
                  Will be free()d.
      @return A new statement, as appropriate.
*/
expr* BuildOptionStatement(option* o, char* n);

/** Build a (checkbox) option statement.
      @param  o     Option to set.
      @param  check If true, we will check lots of boxes.
                    If false, we will uncheck lots of boxes.  
      @param  list  List of names of boxes to be checked / unchecked.
      @return A new statement, as appropriate.
*/
expr* BuildOptionStatement(option* o, bool check, parser_list* list);

/** Find option with specified name.
      @param  name  Name of the option.  Will be free()d.
      @return An option with the same name, if one exists;
              0 otherwise.
*/
option* BuildOptionHeader(char* name);

/** Builds an expression statement.
      @param  x  An expression to compute.
      @return A void expression (statement) that computes \a x.
*/
expr* BuildExprStatement(expr *x);


// ******************************************************************
// *                                                                *
// *                                                                *
// *                    Symbol-related functions                    *
// *                                                                *
// *                                                                *
// ******************************************************************

/** Build an integer variable declaration statement.
      @param  typ     String for variable type (should be "int").
      @param  names   List of variable names.
      @param  values  Set expression, for the possible values of the
                      variable.

*/
expr* BuildIntegers(char* typ, parser_list* names, expr* values);

/** Build a boolean variable declaration statement.
      @param  typ   String for variable type (should be "bool").
      @param  names List of variable names.
*/
expr* BuildBools(char* typ, parser_list* names);

// ******************************************************************
// *                                                                *
// *                                                                *
// *                    Model-related  functions                    *
// *                                                                *
// *                                                                *
// ******************************************************************

/// Start the model.
void StartModel();

/// Finish the model.
void FinishModel();

/** Add a model variable (name) to our list.
    The name is also added to the model's internal symbol table.
      @param  varlist Current list of vars.
      @param  ident   New variable name to add.
      @return Updated list of vars.
*/
parser_list* AddModelVar(parser_list* varlist, char* ident);

/** Build a "maximize" measure statement.
    This handles statements of the form
      maximize ident := rhs;
    The measure is added to the model's symbol tables.
      @param  ident Name of measure.
      @param  rhs   Definition of measure.
      @return measure construction statement,
              or 0 on error (will make noise).
*/
expr* BuildMaximize(char* ident, expr* rhs);

/** Build a "minimize" measure statement.
    This handles statements of the form
      minimize ident := rhs;
    The measure is added to the model's symbol tables.
      @param  ident Name of measure.
      @param  rhs   Definition of measure.
      @return measure construction statement,
              or 0 on error (will make noise).
*/
expr* BuildMinimize(char* ident, expr* rhs);

/** Build a "satisfiable" measure statement.
    This handles statements of the form
      satisfiable ident := rhs;
    The measure is added to the model's symbol tables.
      @param  ident Name of measure.
      @param  rhs   Definition of measure.
      @return measure construction statement,
      or 0 on error (will make noise).
*/
expr* BuildSatisfiable(char* ident, expr* rhs);

// ******************************************************************
// *                                                                *
// *                                                                *
// *                  Expression-related functions                  *
// *                                                                *
// *                                                                *
// ******************************************************************


/** Build a set expression for a single-element set.
      @param  elem  Expression to use for the element.
      @return New set expression as appropriate.
*/
expr* BuildElementSet(expr* elem);

/** Build a set expression for an interval.
    The increment is assumed to be 1.
      @param  start Expression to use for the starting element.
      @param  stop  Expression to use for the stopping element.
      @return New set expression as appropriate.
*/
expr* BuildInterval(expr* start, expr* stop);

/** Build a set expression for an interval.
      @param  start Expression to use for the starting element.
      @param  stop  Expression to use for the stopping element.
      @param  inc   Expression to use for the increment.
      @return New set expression as appropriate.
*/
expr* BuildInterval(expr* start, expr* stop, expr* inc);


/** Build a summation expression from an operator-labeled list.
      @param  list  List of (operator, term).
        These should be "compatible" operators,
        e.g., + and -

      @return New expression as appropriate.
*/
expr* BuildSummation(parser_list* list);


/** Build a product expression from an operator-labeled list.
      @param  list  List of (operator, term).
        These should be "compatible" operators,
        e.g., * and /

      @return New expression as appropriate.
*/
expr* BuildProduct(parser_list* list);


/** Build an associative expression.
      @param  op    Operator to apply.
      @param  list  List of operands.
      @return A new expression, as appropriate.
*/
expr* BuildAssociative(int op, parser_list* list);

/**
    Builds the desired binary expression.

      @param  left  Left expression
      @param  op    Operator; use constants in smart.tab.h
      @param  right Right expression

      @return A new expression as appropriate.
*/
expr* BuildBinary(expr* left, int op, expr* right);

/**
    Type-checks and builds the desired unary expression.

      @param  op    Operator; use constants in smart.tab.h
      @param  opnd  Operand.

      @return A new expression as appropriate.
*/
expr* BuildUnary(int op, expr* opnd);

/** Build a boolean constant.
    
      @param  s   String to build from (i.e., "true" or "false").
                  Will be free()d.

      @return A new expression as appropriate.
*/
expr* MakeBoolConst(char* s);

/** Build an integer constant
    
      @param  s   String to build from (i.e., "153" or "-32").
                  Will be free()d.

      @return A new expression as appropriate.
*/
expr* MakeIntConst(char* s);

/** Find the best "function with no parameters".
    We check formal parameters, for loop iterators, and user-defined
    functions; if not found, we'll return NULL.
      @param  name  Identifier name
      @return A new expression as appropriate.
*/
expr* FindIdent(char* name);

/** Build a function call.
    Does type checking, promotion, overloading, and everything.
      @param  n   The function name.  Will be free()d.
      @param  ind List of passed (positional) parameters
      @return A new expression as appropriate.
*/
expr* BuildFunctionCall(char* n, parser_list* posparams);


// ******************************************************************
// *                                                                *
// *                                                                *
// *                      Front-end  functions                      *
// *                                                                *
// *                                                                *
// ******************************************************************


class parse_module;

/** Initialize the compiler data structures.
*/
void InitCompiler(parse_module* pm);

/** Start parsing.
    The lexer must be set to go.
      @param  env  Environment to use.
      @return The error code passed back by the parser.
*/
int Compile(parse_module* pm);

#endif
