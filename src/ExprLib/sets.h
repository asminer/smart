
// $Id$

#ifndef SETS_H
#define SETS_H

#include "../include/shared.h"

class type;
class result;
class option_manager;

/**   The base class for sets, as generated by a set expression.
      Also used within arrays to define the index values.
      Note: like expressions, we count the number of incoming
      pointers.  That's so we can share the same set
      (for instance, within multiple arrays).

      Large sets of states (e.g., for CTL model checking)
      are defined elsewhere.

      Also, note that these are for finte sets.
*/  
class shared_set : public shared_object {
  /// Number of elements
  long size;  
public:
  shared_set(long s);

  inline long Size() const { return size; }

  /** Get the nth item of the set.
      n must be between 0 and Size()-1.
   */
  virtual void GetElement(long n, result &x) const = 0;

  /** The position of x in the set.
      If x is not contained in the set, we return -1.
      Note that this is the inverse of GetElement.
   */
  virtual long IndexOf(const result &x) const = 0;
};


/** The base class for set converters.
    Used for example for type conversions {int} -> {real}.
*/
class set_converter : public shared_set {
public:
  class element_convert {
  public:
    element_convert();
    virtual ~element_convert();
    /// Convert from the source type to the target type.
    virtual void convert(result &x) const = 0;
    /// Convert from the target type to the source type.
    virtual void revert(result &x) const = 0;
  };
private:
  const element_convert &EC;
protected:
  shared_set* oldset;
public:
  set_converter(const element_convert &ec, shared_set* x);
  virtual ~set_converter();
  virtual void GetElement(long n, result &x) const;
  virtual long IndexOf(const result &x) const;
  virtual bool Print(OutputStream &s, int) const;
  virtual bool Equals(const shared_object* o) const;
};


/** Make a generic singleton set.
      @param  t  Type of the element in the set.
      @param  r  Value of the element to make into a set.
      @return A set containing only the element r,
              or 0 on error.
*/
shared_set* MakeSingleton(const type* t, const result& r);


/** Make an integer range set.
    Build a set of the form {start..stop..inc}
    where start, stop, and inc are integers.
      @param  start   Starting value
      @param  stop    Stopping value
      @param  inc     Increment value
*/
shared_set* MakeRangeSet(long start, long stop, long inc);


/** Make an real range set.
    Build a set of the form {start..stop..inc}
    where start, stop, and inc are reals.
      @param  rt      Type info for REALs
      @param  start   Starting value
      @param  stop    Stopping value
      @param  inc     Increment value
*/
shared_set* MakeRangeSet(const type* rt, double start, double stop, double inc);


/** Make a generic set of items.
      @param  t Type of the items in the set.
      @param  s Size of the set.
      @param  v Values, in "chronological" order.
      @param  o Ordering array, element i should give
                the index of the ith largest value,
                according to "t->compare()".
      @return  The desired set (even if it is empty), or 0 on error.
*/
shared_set* MakeSet(const type* t, long s, result* v, long* o);


/** Make a generic set of items.
    This function builds the appropriate order array 
    and calls the other version of MakeSet.
      @param  t  Type of the items in the set.
      @param  s  Size of the set.
      @param  v  Values, in "chronological" order.
      @return The desired set (even if it is empty), or 0 on error.
*/
shared_set* MakeSet(const type* t, long s, result* v);



#endif

