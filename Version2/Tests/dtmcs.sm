
// $Id$

/* 
   Tests for dtmc formalism and internal stuff
*/

#MatrixByRows true

// A small simple one to check the num_states and num_arcs functions

dtmc d0 := {
  state a,b;
  init(a:1);
  arcs(
  	a:a:1,
	a:b:3,
	b:a:1
  );

  int m1 := num_states(true);
  int m2 := num_arcs(true);
};

print(d0.m1, "\n", d0.m2, "\n");

//
// Check state errors
//

print("Some bad state name errors:\n");

dtmc d1 := {
  state a,b,a;
  init(a:1);
  arcs(
  	a:c:1
  );
};

// 
// Warnings for duplicate arcs and such
//

dtmc d2 := {
  state a,b,c;
  init(a:1, b:1, a:1);
  arcs(
    a:b:1,
    a:c:1,
    a:b:1
  );
  int m1 := num_states(true);
};

print("Warnings for duplicates:\n");
print(d2.m1, "\n");

//
// Check Markov chain classification
//

dtmc d3(int dummy) := {
  state a, 	// absorbing
        b,c,d,	// recurrent class
	e,f,	// recurrent class
	g,h,i,j;  // transients

  init (i:dummy);

  arcs(
  	i : g : 1,
	g : h : 1,
	h : i : 1,

	g : a : 1,
	h : b : 1,
	i : j : 1, j : e : 1,

	e : e : 1, e : f : 1,
	f : e : 1,

	b : c : 1, b : d : 1,
	c : d : 1,
	d : b : 1
  );

  int m1 := num_states(true);
  int m2 := num_arcs(true);
};

# StateDisplayOrder LEXICAL
print("States should appear in definition order: a,b,c,d,e,f,g,h,i,j:\n");
print(d3(1).m1, "\n", d3(1).m2, "\n");

# StateDisplayOrder NATURAL
print("Transients should appear first {g,h,i,j}, then recurrent, then a:\n");
print(d3(2).m1, "\n", d3(2).m2, "\n");

//
// Simple array of states test
//

dtmc d4(int N) := {
  for (int i in {1..N}) {
    state s[i];
  }
  init(s[1]:1);
  for (int i in {2..N}) {
    arcs(s[i-1] : s[i] : 1, s[i] : s[i-1] : 2);
  }
  int m1 := num_states(true);
  int m2 := num_arcs(true);
};

for (int n in {1..5}) {
  print("Birth death with ", n, " states:\n");
  print(d4(n).m1, "\n", d4(n).m2, "\n");
}

